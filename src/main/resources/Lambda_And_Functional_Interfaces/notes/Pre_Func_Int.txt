Predefined Functional Interfaces

Java provides several predefined functional interfaces in the 'java.util.function' package.
These functional interfaces are useful for functional programming and are widely used in stream operations, lambda expressions,
and method references.
Here is a description of some of the most common ones:

* Function<T, R>
- Represents a function that takes an argument of type T and returns a result of type R.
- Abstract method: R apply(T t).
- Example:

    Function<String, Integer> lengthFunction = String::length;
    Integer length = lengthFunction.apply("Hello");
    System.out.println(length);//5

* BiFunction<T, U, R>
- Represents a function that takes two arguments of types T and U and returns a result of type R.
- Abstract method: R apply(T t, U u).
- Example:

    BiFunction<Integer, Integer, Integer> addFunction =(a, b) -> a + b;
    Integer add = addFunction.apply(5, 3);
    System.out.println(add);//8

* Consumer<T>
- Represents an operation that takes an argument of type T and returns no result.
- Abstract method: void accept(T t).
- Example:

    Consumer<String> printConsumer = System.out::println;
    printConsumer.accept("Hello, World!");//Hello, World!

* BiConsumer<T, U>
- Represents an operation that takes two arguments of types T and U and returns no return.
- Abstract method: void accept(T t, U u)M.
- Example:

    BiConsumer<String, Integer> printConsumer = (s, i) -> System.out.println(s + " " + i);
    printConsumer("Age: " + 25);// Age: 25

* Supplier<T>
- Represents a function that takes no arguments and returns a result of type T.
- Abstract method: T get().
- Example:

    Supplier<Double> randomSupplier = Math::random;
    Double randomValue = randomSupplier.get();
    System.out.println(randomValue);//Random value

* Predicate<T>
- Represents a function that takes an argument of type T and returns a boolean
- Abstract method: boolean test(T t).
- Example:

    Predicate<Integer> isEven = n -> n % 2 == 0;
    boolean result = isEven.test(4);
    System.out.println(result);//true

* BiPredicate<T, U>
- Represents a function that takes two arguments of types T and U and returns a boolean.
- Abstract method: boolean test(T t, U u).
- Example:

    BiPredicate<String, String> isEqual = String::equals;
    boolean result = isEqual.test("Hello", "Hello");
    System.out.println(result);//true

Functional Interfaces for Primitive Types
These functional interfaces are designed to work specifically with primitive types (int, long, double) to avoid autoboxing,
which improves performance.

* IntFunction<R>
- Represents a function that takes an int as input and returns a result of type R.
- Abstract method: R apply(int value).
- Example:

    IntFunction<String> intToString = Integer::toString;
    String result = intToString.apply(123);
    System.out.println(result);//"123"

* IntConsumer
- Represents an operation that accepts a single int value and returns no result.
- Abstract method: void accept(int value).
- Example:

    IntConsumer printInt = System.out::println
    printInt.accept(123);//123

* IntPredicate
- Represents a function that takes an int as input and returns a boolean.
- Abstract method: boolean test(int value).
- Example:

    IntPredicate isEven = n -> n % 2 == 0;
    boolean result = isEven.test(4);
    System.out.println(result);//true

* IntSupplier
- Represents a function that takes no arguments and returns an int.
- Abstract method: int getAsInt().
- Example:

    IntSupplier randomSupplier = () -> (int)(Math.random() * 100);
    int randomValue = randomSupplier.getAsInt();
    System.out.println(randomValue);//Some random value int

***
The way of use is similar to the previous examples:
* LongFunction<R>
* LongConsumer
* LongPredicate
* LongSupplier
* DoubleFunction<R>
* DoubleConsumer
* DoublePredicate
* DoubleSupplier

Others:
Las interfaces funcionales diseñadas para trabajar con tipos primitivos (`int`, `long`, `double`)
están diseñadas para evitar el autoboxing, lo que a su vez mejora el rendimiento.
Aquí hay una explicación más detallada:

### Evitar el Autoboxing con Interfaces Funcionales para Tipos Primitivos

#### ¿Qué es el Autoboxing?

El autoboxing es el proceso automático de convertir tipos primitivos a sus correspondientes clases envolventes. Por ejemplo:
- `int` a `Integer`
- `double` a `Double`

#### ¿Qué es el Unboxing?

El unboxing es el proceso inverso: convertir una clase envolvente de vuelta a su tipo primitivo correspondiente. Por ejemplo:
- `Integer` a `int`
- `Double` a `double`

### Impacto del Autoboxing y Unboxing en el Rendimiento

El autoboxing y unboxing implican operaciones adicionales que pueden tener un impacto en el rendimiento, especialmente en contextos donde se manejan grandes volúmenes de datos o en bucles intensivos. Estas operaciones adicionales incluyen:
- Creación de nuevos objetos para clases envolventes.
- Mayor uso de memoria debido a la necesidad de almacenar objetos adicionales.
- Posible desecho de objetos y mayor presión en el recolector de basura.

### Ejemplo de Impacto en el Rendimiento

Imagina que estamos utilizando una `Function<Integer, Integer>` para incrementar un número en un stream de enteros:

```java
Function<Integer, Integer> increment = n -> n + 1;
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> incrementedNumbers = numbers.stream()
                                          .map(increment)
                                          .collect(Collectors.toList());
```

En este ejemplo:
- Cada `int` se convierte en `Integer` cuando se coloca en la lista (`autoboxing`).
- Cada `Integer` se convierte de nuevo a `int` para la operación `n + 1` (`unboxing`).
- El resultado de `n + 1` se convierte de nuevo en `Integer` para almacenar en la lista resultante (`autoboxing`).

Estas conversiones repetidas pueden reducir la eficiencia del código.

### Uso de Interfaces Funcionales Especializadas para Tipos Primitivos

Para evitar el autoboxing y mejorar el rendimiento, Java proporciona interfaces funcionales especializadas para tipos primitivos. Aquí hay algunos ejemplos:

#### `IntFunction<R>`
- Evita el autoboxing de `int` a `Integer` y viceversa.
- Ejemplo:
  ```java
  IntFunction<String> intToString = Integer::toString;
  String result = intToString.apply(123);
  System.out.println(result); // Salida: "123"
  ```

#### `IntConsumer`
- Evita el autoboxing de `int` a `Integer` y viceversa.
- Ejemplo:
  ```java
  IntConsumer printInt = System.out::println;
  printInt.accept(123); // Salida: 123
  ```

#### `IntPredicate`
- Evita el autoboxing de `int` a `Integer` y viceversa.
- Ejemplo:
  ```java
  IntPredicate isEven = n -> n % 2 == 0;
  boolean result = isEven.test(4);
  System.out.println(result); // Salida: true
  ```

### Comparación de Ejemplo

#### Usando `Function<Integer, Integer>` (con autoboxing)

```java
Function<Integer, Integer> increment = n -> n + 1;
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> incrementedNumbers = numbers.stream()
                                          .map(increment)
                                          .collect(Collectors.toList());
```

#### Usando `IntUnaryOperator` (sin autoboxing)

```java
IntUnaryOperator increment = n -> n + 1;
int[] numbers = {1, 2, 3, 4, 5};
int[] incrementedNumbers = Arrays.stream(numbers)
                                 .map(increment)
                                 .toArray();
```

En el segundo ejemplo:
- No hay necesidad de convertir `int` a `Integer` o viceversa.
- Las operaciones se realizan directamente en los tipos primitivos, lo que mejora el rendimiento.

### Conclusión

Usar interfaces funcionales especializadas para tipos primitivos (`IntFunction`, `IntConsumer`, `IntPredicate`, `IntSupplier`, `LongFunction`, `LongConsumer`, `LongPredicate`, `LongSupplier`, `DoubleFunction`, `DoubleConsumer`, `DoublePredicate`, `DoubleSupplier`) es una buena práctica para evitar el autoboxing y unboxing, mejorando así el rendimiento del código. Esto es especialmente importante en contextos donde se manejan grandes volúmenes de datos o se realizan operaciones intensivas.